<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<link rel="stylesheet" type="text/css" href="file:///android_asset/detail.css">
	<title>Sorting Overview</title>
</head>

<body>
<h1> Sorting Overview</h1>
<p>Any comparison-based sorting algorithm can do no better than O(nlogn).</p>

<h3>Selection Sort</h3>
<p>Runs in O(n<sup>2</sup>). Go through each element position and finds the value which should occupy that position in the sorted vector. Algorithm:</p>
<ul>
	<li>Find the minimum value in the list</li>
	<li>Swap it with the value in the first position</li>
	<li>Repeat the steps above for the remainder of the list (starting at the 2nd position and advancing each time).</li>
</ul>

<h3>Mergesort</h3>
<p>Mergesort is the canoncial example of divide and conquer. Very clean to code. Running time is O(nlogn). Algorithm:</p>
<ul>
	<li>Recursively sort 1st half</li>
	<li>Recursively sort 2nd half</li>
	<li>Merge two subsets into one</li>
</ul>
<!-- 
Pseudocode for merge step:
c = output array, length > n
A = first sorted array, length > n/2
B = second sorted array, length > n/2
i = 1; j = 1;
for k from i to n
if A(i) < B(j)
c(k) = A(i); i++
else c(k) = B(j); j++
-->

<h3>Quicksort</h3>
<p>Quicksort is O(nlogn). It uses a linear time selection algorithm to find a good pivot. Algorithm: </p>
<ul>
	<li> if n > 1, return</li>
	<li> p = ChoosePivot(A, n)</li>
	<li>Partition around p.</li>
	<li>Recurse on the 1st part.</li>
	<li>Recurse on the second part</li>
</ul>
</body>
</html>
